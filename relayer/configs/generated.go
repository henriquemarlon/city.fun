// Code generated by internal/config/generate.
// DO NOT EDIT.

package configs

import (
	"fmt"
	"os"
	"strings"

	"github.com/spf13/viper"
)

var ErrNotDefined = fmt.Errorf("variable not defined")

func init() {
	// Automatically bind environment variables.
	viper.AutomaticEnv()
}

const (
	AUTH_KIND                      = "RELAYER_AUTH_KIND"
	AUTH_MNEMONIC                  = "RELAYER_AUTH_MNEMONIC"
	AUTH_MNEMONIC_ACCOUNT_INDEX    = "RELAYER_AUTH_MNEMONIC_ACCOUNT_INDEX"
	AUTH_PRIVATE_KEY               = "RELAYER_AUTH_PRIVATE_KEY"
	BLOCKCHAIN_HTTP_ENDPOINT       = "RELAYER_BLOCKCHAIN_HTTP_ENDPOINT"
	BLOCKCHAIN_HTTP_MAX_RETRIES    = "RELAYER_BLOCKCHAIN_HTTP_MAX_RETRIES"
	BLOCKCHAIN_HTTP_RETRY_MAX_WAIT = "RELAYER_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT"
	BLOCKCHAIN_HTTP_RETRY_MIN_WAIT = "RELAYER_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT"
	BLOCKCHAIN_ID                  = "RELAYER_BLOCKCHAIN_ID"
	REWARD_TOKEN_ADDRESS           = "RELAYER_REWARD_TOKEN_ADDRESS"
	DATABASE_COLLECTION            = "RELAYER_DATABASE_COLLECTION"
	DATABASE_NAME                  = "RELAYER_DATABASE_NAME"
	DATABASE_URL                   = "RELAYER_DATABASE_URL"
	KAFKA_BROKER                   = "RELAYER_KAFKA_BROKER"
	KAFKA_TOPICS                   = "RELAYER_KAFKA_TOPICS"
	LOG_COLOR                      = "RELAYER_LOG_COLOR"
	LOG_LEVEL                      = "RELAYER_LOG_LEVEL"
	MAX_STARTUP_TIME               = "RELAYER_MAX_STARTUP_TIME"
	TELEMETRY_ADDRESS              = "RELAYER_TELEMETRY_ADDRESS"

	// File variants

	AUTH_MNEMONIC_FILE = "RELAYER_AUTH_MNEMONIC_FILE"

	AUTH_PRIVATE_KEY_FILE         = "RELAYER_AUTH_PRIVATE_KEY_FILE"
	BLOCKCHAIN_HTTP_ENDPOINT_FILE = "RELAYER_BLOCKCHAIN_HTTP_ENDPOINT_FILE"

	DATABASE_URL_FILE = "RELAYER_DATABASE_URL_FILE"
)

func SetDefaults() {
	// Set defaults based on the TOML definitions.

	viper.SetDefault(AUTH_KIND, "AuthKindPrivateKeyVar")

	// no default for RELAYER_AUTH_MNEMONIC

	viper.SetDefault(AUTH_MNEMONIC_ACCOUNT_INDEX, "0")

	// no default for RELAYER_AUTH_PRIVATE_KEY

	// no default for RELAYER_BLOCKCHAIN_HTTP_ENDPOINT

	viper.SetDefault(BLOCKCHAIN_HTTP_MAX_RETRIES, "4")

	viper.SetDefault(BLOCKCHAIN_HTTP_RETRY_MAX_WAIT, "60")

	viper.SetDefault(BLOCKCHAIN_HTTP_RETRY_MIN_WAIT, "1")

	// no default for RELAYER_BLOCKCHAIN_ID

	// no default for RELAYER_REWARD_TOKEN_ADDRESS

	// no default for RELAYER_DATABASE_COLLECTION

	// no default for RELAYER_DATABASE_NAME

	// no default for RELAYER_DATABASE_URL

	viper.SetDefault(KAFKA_BROKER, "localhost:9092")

	// no default for RELAYER_KAFKA_TOPICS

	viper.SetDefault(LOG_COLOR, "true")

	viper.SetDefault(LOG_LEVEL, "info")

	viper.SetDefault(MAX_STARTUP_TIME, "15")

	// no default for RELAYER_TELEMETRY_ADDRESS

}

// RelayerConfig holds configuration values for the relayer service.
type RelayerConfig struct {

	// HTTP endpoint for the blockchain RPC provider.
	BlockchainHttpEndpoint URL `mapstructure:"RELAYER_BLOCKCHAIN_HTTP_ENDPOINT"`

	// Maximum number of retry attempts for HTTP blockchain requests after encountering an error.
	BlockchainHttpMaxRetries uint64 `mapstructure:"RELAYER_BLOCKCHAIN_HTTP_MAX_RETRIES"`

	// Maximum wait time in seconds for the exponential backoff retry policy. The delay between retries for HTTP blockchain requests will never exceed this value, regardless of the backoff calculation.
	BlockchainHttpRetryMaxWait Duration `mapstructure:"RELAYER_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT"`

	// Minimum wait time in seconds for the exponential backoff retry policy. This is the initial delay before the first retry for HTTP blockchain requests.
	BlockchainHttpRetryMinWait Duration `mapstructure:"RELAYER_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT"`

	// An unique identifier representing a blockchain network.
	BlockchainId uint64 `mapstructure:"RELAYER_BLOCKCHAIN_ID"`

	// Address of the RewardToken contract.
	RewardToken Address `mapstructure:"RELAYER_REWARD_TOKEN_ADDRESS"`

	// MongoDB collection for the database
	DatabaseCollection RedactedString `mapstructure:"RELAYER_DATABASE_COLLECTION"`

	// MongoDB name for the database
	DatabaseName RedactedString `mapstructure:"RELAYER_DATABASE_NAME"`

	// MongoDB URL for the database (supports file-based secrets via RELAYER_DATABASE_URL_FILE)
	DatabaseUrl URL `mapstructure:"RELAYER_DATABASE_URL"`

	// Kafka brokers for the service
	KafkaBroker URL `mapstructure:"RELAYER_KAFKA_BROKER"`

	// Kafka topics for the service
	KafkaTopics []string `mapstructure:"RELAYER_KAFKA_TOPICS"`

	// Log color for the service
	LogColor bool `mapstructure:"RELAYER_LOG_COLOR"`

	// Log level for the service
	LogLevel LogLevel `mapstructure:"RELAYER_LOG_LEVEL"`

	// Maximum startup time for the service
	MaxStartupTime Duration `mapstructure:"RELAYER_MAX_STARTUP_TIME"`

	// Telemetry address for the service
	TelemetryAddress string `mapstructure:"RELAYER_TELEMETRY_ADDRESS"`
}

// LoadRelayerConfig reads configuration from environment variables, a config file, and defaults.
// Priority: command line flags > environment variables > config file > defaults.
func LoadRelayerConfig() (*RelayerConfig, error) {
	SetDefaults()

	// Load config file if specified via --config flag.
	if cfgFile := viper.GetString("config"); cfgFile != "" {
		viper.SetConfigFile(cfgFile)
		if err := viper.ReadInConfig(); err != nil {
			return nil, fmt.Errorf("error reading config file: %w", err)
		}
	}

	var cfg RelayerConfig
	var err error

	cfg.BlockchainHttpEndpoint, err = GetBlockchainHttpEndpoint()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_BLOCKCHAIN_HTTP_ENDPOINT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_BLOCKCHAIN_HTTP_ENDPOINT is required for the relayer service: %w", err)
	}

	cfg.BlockchainHttpMaxRetries, err = GetBlockchainHttpMaxRetries()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_BLOCKCHAIN_HTTP_MAX_RETRIES: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_BLOCKCHAIN_HTTP_MAX_RETRIES is required for the relayer service: %w", err)
	}

	cfg.BlockchainHttpRetryMaxWait, err = GetBlockchainHttpRetryMaxWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT is required for the relayer service: %w", err)
	}

	cfg.BlockchainHttpRetryMinWait, err = GetBlockchainHttpRetryMinWait()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT is required for the relayer service: %w", err)
	}

	cfg.BlockchainId, err = GetBlockchainId()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_BLOCKCHAIN_ID: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_BLOCKCHAIN_ID is required for the relayer service: %w", err)
	}

	cfg.RewardToken, err = GetRewardTokenAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_REWARD_TOKEN_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_REWARD_TOKEN_ADDRESS is required for the relayer service: %w", err)
	}

	cfg.DatabaseCollection, err = GetDatabaseCollection()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_DATABASE_COLLECTION: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_DATABASE_COLLECTION is required for the relayer service: %w", err)
	}

	cfg.DatabaseName, err = GetDatabaseName()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_DATABASE_NAME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_DATABASE_NAME is required for the relayer service: %w", err)
	}

	cfg.DatabaseUrl, err = GetDatabaseUrl()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_DATABASE_URL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_DATABASE_URL is required for the relayer service: %w", err)
	}

	cfg.KafkaBroker, err = GetKafkaBroker()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_KAFKA_BROKER: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_KAFKA_BROKER is required for the relayer service: %w", err)
	}

	cfg.KafkaTopics, err = GetKafkaTopics()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_KAFKA_TOPICS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_KAFKA_TOPICS is required for the relayer service: %w", err)
	}

	cfg.LogColor, err = GetLogColor()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_LOG_COLOR: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_LOG_COLOR is required for the relayer service: %w", err)
	}

	cfg.LogLevel, err = GetLogLevel()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_LOG_LEVEL: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_LOG_LEVEL is required for the relayer service: %w", err)
	}

	cfg.MaxStartupTime, err = GetMaxStartupTime()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_MAX_STARTUP_TIME: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_MAX_STARTUP_TIME is required for the relayer service: %w", err)
	}

	cfg.TelemetryAddress, err = GetTelemetryAddress()
	if err != nil && err != ErrNotDefined {
		return nil, fmt.Errorf("failed to get RELAYER_TELEMETRY_ADDRESS: %w", err)
	} else if err == ErrNotDefined {
		return nil, fmt.Errorf("RELAYER_TELEMETRY_ADDRESS is required for the relayer service: %w", err)
	}

	return &cfg, nil
}

// GetAuthKind returns the value for the environment variable RELAYER_AUTH_KIND.
func GetAuthKind() (AuthKind, error) {
	s := viper.GetString(AUTH_KIND)
	if s != "" {
		v, err := toAuthKind(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_KIND, err)
		}
		return v, nil
	}
	return notDefinedAuthKind(), fmt.Errorf("%s: %w", AUTH_KIND, ErrNotDefined)
}

// GetAuthMnemonic returns the value for the environment variable RELAYER_AUTH_MNEMONIC.
func GetAuthMnemonic() (RedactedString, error) {
	s := viper.GetString(AUTH_MNEMONIC)
	if s == "" {
		filename := viper.GetString(AUTH_MNEMONIC_FILE)
		contents, err := os.ReadFile(filename)
		if err != nil {
			return notDefinedRedactedString(), fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC_FILE, err)
		}
		s = strings.TrimSpace(string(contents))
	}
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", AUTH_MNEMONIC, ErrNotDefined)
}

// GetAuthMnemonicAccountIndex returns the value for the environment variable RELAYER_AUTH_MNEMONIC_ACCOUNT_INDEX.
func GetAuthMnemonicAccountIndex() (RedactedUint, error) {
	s := viper.GetString(AUTH_MNEMONIC_ACCOUNT_INDEX)
	if s != "" {
		v, err := toRedactedUint(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_MNEMONIC_ACCOUNT_INDEX, err)
		}
		return v, nil
	}
	return notDefinedRedactedUint(), fmt.Errorf("%s: %w", AUTH_MNEMONIC_ACCOUNT_INDEX, ErrNotDefined)
}

// GetAuthPrivateKey returns the value for the environment variable RELAYER_AUTH_PRIVATE_KEY.
func GetAuthPrivateKey() (RedactedString, error) {
	s := viper.GetString(AUTH_PRIVATE_KEY)
	if s == "" {
		filename := viper.GetString(AUTH_PRIVATE_KEY_FILE)
		contents, err := os.ReadFile(filename)
		if err != nil {
			return notDefinedRedactedString(), fmt.Errorf("failed to parse %s: %w", AUTH_PRIVATE_KEY_FILE, err)
		}
		s = strings.TrimSpace(string(contents))
	}
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", AUTH_PRIVATE_KEY, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", AUTH_PRIVATE_KEY, ErrNotDefined)
}

// GetBlockchainHttpEndpoint returns the value for the environment variable RELAYER_BLOCKCHAIN_HTTP_ENDPOINT.
func GetBlockchainHttpEndpoint() (URL, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_ENDPOINT)
	if s == "" {
		filename := viper.GetString(BLOCKCHAIN_HTTP_ENDPOINT_FILE)
		contents, err := os.ReadFile(filename)
		if err != nil {
			return notDefinedURL(), fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_ENDPOINT_FILE, err)
		}
		s = strings.TrimSpace(string(contents))
	}
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_ENDPOINT, err)
		}
		return v, nil
	}
	return notDefinedURL(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_ENDPOINT, ErrNotDefined)
}

// GetBlockchainHttpMaxRetries returns the value for the environment variable RELAYER_BLOCKCHAIN_HTTP_MAX_RETRIES.
func GetBlockchainHttpMaxRetries() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_MAX_RETRIES)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_MAX_RETRIES, err)
		}
		return v, nil
	}
	return notDefinedUint64(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_MAX_RETRIES, ErrNotDefined)
}

// GetBlockchainHttpRetryMaxWait returns the value for the environment variable RELAYER_BLOCKCHAIN_HTTP_RETRY_MAX_WAIT.
func GetBlockchainHttpRetryMaxWait() (Duration, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_RETRY_MAX_WAIT)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_RETRY_MAX_WAIT, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_RETRY_MAX_WAIT, ErrNotDefined)
}

// GetBlockchainHttpRetryMinWait returns the value for the environment variable RELAYER_BLOCKCHAIN_HTTP_RETRY_MIN_WAIT.
func GetBlockchainHttpRetryMinWait() (Duration, error) {
	s := viper.GetString(BLOCKCHAIN_HTTP_RETRY_MIN_WAIT)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_HTTP_RETRY_MIN_WAIT, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", BLOCKCHAIN_HTTP_RETRY_MIN_WAIT, ErrNotDefined)
}

// GetBlockchainId returns the value for the environment variable RELAYER_BLOCKCHAIN_ID.
func GetBlockchainId() (uint64, error) {
	s := viper.GetString(BLOCKCHAIN_ID)
	if s != "" {
		v, err := toUint64(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", BLOCKCHAIN_ID, err)
		}
		return v, nil
	}
	return notDefinedUint64(), fmt.Errorf("%s: %w", BLOCKCHAIN_ID, ErrNotDefined)
}

// GetRewardTokenAddress returns the value for the environment variable RELAYER_REWARD_TOKEN_ADDRESS.
func GetRewardTokenAddress() (Address, error) {
	s := viper.GetString(REWARD_TOKEN_ADDRESS)
	if s != "" {
		v, err := toAddress(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", REWARD_TOKEN_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedAddress(), fmt.Errorf("%s: %w", REWARD_TOKEN_ADDRESS, ErrNotDefined)
}

// GetDatabaseCollection returns the value for the environment variable RELAYER_DATABASE_COLLECTION.
func GetDatabaseCollection() (RedactedString, error) {
	s := viper.GetString(DATABASE_COLLECTION)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", DATABASE_COLLECTION, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", DATABASE_COLLECTION, ErrNotDefined)
}

// GetDatabaseName returns the value for the environment variable RELAYER_DATABASE_NAME.
func GetDatabaseName() (RedactedString, error) {
	s := viper.GetString(DATABASE_NAME)
	if s != "" {
		v, err := toRedactedString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", DATABASE_NAME, err)
		}
		return v, nil
	}
	return notDefinedRedactedString(), fmt.Errorf("%s: %w", DATABASE_NAME, ErrNotDefined)
}

// GetDatabaseUrl returns the value for the environment variable RELAYER_DATABASE_URL.
func GetDatabaseUrl() (URL, error) {
	s := viper.GetString(DATABASE_URL)
	if s == "" {
		filename := viper.GetString(DATABASE_URL_FILE)
		contents, err := os.ReadFile(filename)
		if err != nil {
			return notDefinedURL(), fmt.Errorf("failed to parse %s: %w", DATABASE_URL_FILE, err)
		}
		s = strings.TrimSpace(string(contents))
	}
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", DATABASE_URL, err)
		}
		return v, nil
	}
	return notDefinedURL(), fmt.Errorf("%s: %w", DATABASE_URL, ErrNotDefined)
}

// GetKafkaBroker returns the value for the environment variable RELAYER_KAFKA_BROKER.
func GetKafkaBroker() (URL, error) {
	s := viper.GetString(KAFKA_BROKER)
	if s != "" {
		v, err := toURL(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", KAFKA_BROKER, err)
		}
		return v, nil
	}
	return notDefinedURL(), fmt.Errorf("%s: %w", KAFKA_BROKER, ErrNotDefined)
}

// GetKafkaTopics returns the value for the environment variable RELAYER_KAFKA_TOPICS.
func GetKafkaTopics() ([]string, error) {
	s := viper.GetString(KAFKA_TOPICS)
	if s != "" {
		v, err := toSliceString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", KAFKA_TOPICS, err)
		}
		return v, nil
	}
	return notDefinedSliceString(), fmt.Errorf("%s: %w", KAFKA_TOPICS, ErrNotDefined)
}

// GetLogColor returns the value for the environment variable RELAYER_LOG_COLOR.
func GetLogColor() (bool, error) {
	s := viper.GetString(LOG_COLOR)
	if s != "" {
		v, err := toBool(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", LOG_COLOR, err)
		}
		return v, nil
	}
	return notDefinedBool(), fmt.Errorf("%s: %w", LOG_COLOR, ErrNotDefined)
}

// GetLogLevel returns the value for the environment variable RELAYER_LOG_LEVEL.
func GetLogLevel() (LogLevel, error) {
	s := viper.GetString(LOG_LEVEL)
	if s != "" {
		v, err := toLogLevel(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", LOG_LEVEL, err)
		}
		return v, nil
	}
	return notDefinedLogLevel(), fmt.Errorf("%s: %w", LOG_LEVEL, ErrNotDefined)
}

// GetMaxStartupTime returns the value for the environment variable RELAYER_MAX_STARTUP_TIME.
func GetMaxStartupTime() (Duration, error) {
	s := viper.GetString(MAX_STARTUP_TIME)
	if s != "" {
		v, err := toDuration(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", MAX_STARTUP_TIME, err)
		}
		return v, nil
	}
	return notDefinedDuration(), fmt.Errorf("%s: %w", MAX_STARTUP_TIME, ErrNotDefined)
}

// GetTelemetryAddress returns the value for the environment variable RELAYER_TELEMETRY_ADDRESS.
func GetTelemetryAddress() (string, error) {
	s := viper.GetString(TELEMETRY_ADDRESS)
	if s != "" {
		v, err := toString(s)
		if err != nil {
			return v, fmt.Errorf("failed to parse %s: %w", TELEMETRY_ADDRESS, err)
		}
		return v, nil
	}
	return notDefinedString(), fmt.Errorf("%s: %w", TELEMETRY_ADDRESS, ErrNotDefined)
}
